// --- Updated Socket Handlers ---
socket.on('opponentMove', (data) => {
    const m = data.moveData;
    // Perform the move locally
    applyMoveToBoard(m.r1, m.c1, m.r2, m.c2, m.jump);
    // Sync the turn from the server
    turn = data.nextTurn; 
    mustContinueJump = null; // Reset jump state for the player who just waited
    updateStatus();
    render();
});

// --- Split logic into Apply and Execute ---
function applyMoveToBoard(r1, c1, r2, c2, jump) {
    const p = board[r1][c1];
    board[r2][c2] = { ...p };
    board[r1][c1] = { type: 0, king: false };

    if (jump) {
        board[jump.captured.r][jump.captured.c] = { type: 0, king: false };
    }

    // Promotion
    if (!board[r2][c2].king && (board[r2][c2].type === 1 ? r2 === 0 : r2 === 7)) {
        board[r2][c2].king = true;
    }
}

function executeMove(r1, c1, r2, c2, jump, isMyMove) {
    applyMoveToBoard(r1, c1, r2, c2, jump);

    let moreJumps = false;
    if (jump) {
        const subsequent = getCaptures(r2, c2);
        if (subsequent.length > 0) moreJumps = true;
    }

    if (isMyMove) {
        if (moreJumps) {
            mustContinueJump = { r: r2, c: c2 };
            selected = { r: r2, c: c2 };
            // Don't change turn yet, just render
            render();
        } else {
            // End of turn
            const nextTurn = (myColor === 1) ? 2 : 1;
            socket.emit('makeMove', { 
                roomId, 
                moveData: { r1, c1, r2, c2, jump, nextTurn: nextTurn } 
            });
            // We don't change local turn yet, we wait for server 'opponentMove' 
            // to keep both screens perfectly synced.
        }
    }
}
